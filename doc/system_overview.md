# System overview with all tunable parameters

The system consists of the following parts:
1. Simulation control: auto_motion.py
1. Gazebo Jackal simulation
1. Data processing: read_gazebo_data.py
1. Kalman filter: kalman.py
1. Active Inference: active_inference.py

Tunable parameters are displayed in **bold**.


## Simulation control (auto_motion.py)
**Publish rate = 50 Hz**
- Exact frequency does not have an influence on the simulation results (tested for cmd_vel 50 Hz and 10000 Hz at model states update time 10000 Hz)
- Only in case of Teleop Twist Keyboard interaction, the standard motion is interrupted and the robot motion can be ajusted by pressing the keys corresponding to the desired adjustment

**Motion = [0.3, 0.0, 0.0] m/s, [0.0, 0.0, 22.5/180*pi] rad/s (Twist message)**
- Same motion as used in thesis Alex van Doeveren. This is chosen to be the same, because the same robot model is used


## Gazebo Jackal simulation
**/worlds/empty.world: set friction model to cone_model (under physics => ode => solver => friction_model)**
- Skid-steer robot is simulated => important, but difficult to model contact point wheels with ground. The cone model results in the most smooth motion

Gazebo model states data:
- **/worlds/empty.world: set max_step_size equal to 0.001 (under physics => max_step_size)**
- **/worlds/empty.world: set real_time_factor equal to 1 (under physics => real_time_factor)**
- **/worlds/empty.world: set real_time_update equal to 1000 (under physics => real_time_update)**
- Gazebo model states data used, because this gives the ground truth of the simulation. For experiments with the physical Jackal robot, the IMU data needs to be used
- This data is assumed to be white noise, which is modelled with sigma_w = 8.65*10^(-3) rad/s and s_w = 0

Gazebo joint states data:
- **/config/jackal_robot_control.yaml: jackal_joint_publisher.publish_rate = 1000 Hz**
- Wheel velocities on one side of the robot are not exactly the same, probably caused by their different positions on the robot. These are averaged to get the LTI model input
- A frequency of 1000 Hz is needed in order to approach the simulation frequency


## Data processing (read_gazebo_data.py)
**T = 17 s**
- Total time for which coloured noise is generated, do not simulate longer than this time!
- After T s, noise with value 0 is added to the signal

**dt = 0.001 s**
- Sampling period corresponding to 1 kHz frequency of data being published on the /gazebo/model_states topic

**sigma_w = 8.65*10^(-3) rad/s**
- Standard deviation of white process noise
- Estimated by subtracting the LTI model system output from the data of the Gazebo system output (/gazebo/model_states topic). The remaining signal is considered as process noise

**s_w = 0 s**
- Standard deviation of Gaussian filter used to parameterize the coloured process noise
- The process noise is assumed to be white

**sigma_z = 5*sigma_w rad/s**
- Standard deviation of white output noise
- This value is taken, such that the amplitude of the output noise is visible, but stays within reasonable bounds

**s_z = 0.1 s**
- Standard deviation of the Guassian filter used to parameterize and construct the coloured output noise
- Should satisfy two criteria:
  - Nyquist => safely choose this value to be 10 times higher than the simulation sampling time
  - Convolution over total simulation time => choose this value to be at 100 times lower than the total simulation time


## Kalman filter (kalman.py)
**Operating point: mean_u = [4.18; 1.94] rad/s, mean_y = 0.40 rad/s**
- *mean_u* represents the operating point of the model inputs (right and left wheel velocities, respectively)
- *mean_y* represents the operating point of the model output (rotational velocity)
- The LTI model can only account for variations around the operating point, so before going into the filter, the control input and system output should be transformed from operating point to origin. After running the Kalman filter the state estimate should be transformed from origin back to the operating point

**x_k_k = 0 rad/s**
- This variable becomes the state estimate at time step k, given the information on time step k, once the filter is running
- This state estimate should be initialised to zero (as to have a fair comparison of Kalman and Active Inference filter)

**P_k_k = 0 rad^2/s^2**
- Initial error covariance matrix indicating how confident the algorithm is with the state estimate (0 indicates being very confident)

**Discrete-time system matrices: A = 0.81, B = [0.015, -0.015], C = 1**
- Same as in thesis Alex van Doeveren, but using the dedicated optimised values for d_long and d_lat using the Gazebo simulation data

**Q = sigma_w^2 rad^2/s^2**
- Process noice covariance matrix
- sigma_w will be generated by the read_gazebo_data.py script
- Kalman filter can only model white noise, so process noise is modelled as being white

**R = sigma_z^2 rad^2/s^2**
- Output noise covariance matrix
- sigma_z will be generated by the read_gazebo_data.py script
- Kalman filter can only model white noise, so output noise is modelled as being white


## Active Inference (active_inference.py)
**Operating point: mean_u = [4.18; 1.94] rad/s, mean_y = 0.40 rad/s**
- *mean_u* represents the operating point of the model inputs (right and left wheel velocities, respectively)
- *mean_y* represents the operating point of the model output (rotational velocity)
- The LTI model can only account for variations around the operating point, so before going into the filter, the control input and system output should be transformed from operating point to origin. After running the AI algorithm the state estimate should be transformed from origin back to the operating point
- The control input calculation is not implemented yet!

**delta_t = 0.001 s**
- Sampling period corresponding to 1 kHz frequency of data being published on gazebo/model_states topic
- delta_t will be generated by the read_gazebo_data.py script

**p = 6**
- Embedding order indicating how big the generalized state estimate should be. p=1 means: mu = E[x^T; x_accent^T]

**x_0 = 0 rad/s**
- Initial state estimate, only used to construct mu_0 = 0 (being the initial generalized state estimate)

**alpha_mu = 3.408*10^(-6)**
- Learning rate used when minimizing the free energy with respect to mu in the mu_dot update rule

**alpha_u = 0.01**
- Learning rate used when minimizing the free energy with respect to u in the u_dot update rule
- This value is not used, because the control input update rule is not implemented yet!

**Continuous-time system matrices: A = -209.68, B = [16.92, -16.92], C = 1**
- Same as in thesis Alex van Doeveren, but using the dedicated optimised values for d_long and d_lat using the Gazebo simulation data

**x_ref = 0 rad/s**
- Reference signal going into the active inference filter
- This also implies: mu_ref = 0 (being the generalised state reference), and thus: xi = 0 (being the prior)
- This is desired in order to have a fair comparison between Kalman and active inference filter

**G = -CA^(-1)B**
- Forward model used in u update rule
- This value is not used, because the control input update rule is not implemented yet!
